lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / unique(res$dTrue),
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
theme_classic()
x = rbinom(n = n,
size = 1,
prob = 0.5)
#set.seed(seed+1)
y = rnorm(n = n,
mean = 2 * x)  # coefficient is population ds
d = data.frame(x, y)
##### Compare True to Converted d #####
res = data.frame( q = seq(0.01, 0.99, 0.05))
res = res %>% rowwise() %>%
mutate( get_SMDs(q) )
min(res$dConv)
max(res$dConv)
ggplot( data = res,
aes(x = q,
y = dConv) ) +
# true d doesn't depend on cutoff, so there's only 1 unique value
geom_hline( yintercept = unique(res$dTrue),
lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / unique(res$dTrue),
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
theme_classic()
#set.seed(seed)
x = rbinom(n = n,
size = 1,
prob = 0.5)
#set.seed(seed+1)
y = rnorm(n = n,
mean = .5 * x)  # coefficient is population ds
d = data.frame(x, y)
##### Compare True to Converted d #####
res = data.frame( q = seq(0.01, 0.99, 0.05))
res = res %>% rowwise() %>%
mutate( get_SMDs(q) )
min(res$dConv)
max(res$dConv)
ggplot( data = res,
aes(x = q,
y = dConv) ) +
# true d doesn't depend on cutoff, so there's only 1 unique value
geom_hline( yintercept = unique(res$dTrue),
lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / unique(res$dTrue),
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
theme_classic()
#set.seed(seed)
x = rbinom(n = n,
size = 1,
prob = 0.5)
#set.seed(seed+1)
y = rnorm(n = n,
mean = .5 * x)  # coefficient is population ds
d = data.frame(x, y)
##### Compare True to Converted d #####
res = data.frame( q = seq(0.01, 0.99, 0.05))
res = res %>% rowwise() %>%
mutate( get_SMDs(q) )
min(res$dConv)
max(res$dConv)
ggplot( data = res,
aes(x = q,
y = dConv) ) +
# true d doesn't depend on cutoff, so there's only 1 unique value
geom_hline( yintercept = unique(res$dTrue),
lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / unique(res$dTrue),
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
theme_classic()
#set.seed(seed+1)
y = rnorm(n = n,
mean = .3 * x)  # coefficient is population ds
d = data.frame(x, y)
##### Compare True to Converted d #####
res = data.frame( q = seq(0.01, 0.99, 0.05))
res = res %>% rowwise() %>%
mutate( get_SMDs(q) )
min(res$dConv)
max(res$dConv)
ggplot( data = res,
aes(x = q,
y = dConv) ) +
# true d doesn't depend on cutoff, so there's only 1 unique value
geom_hline( yintercept = unique(res$dTrue),
lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / unique(res$dTrue),
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
theme_classic()
x = rbinom(n = n,
size = 1,
prob = 0.5)
#set.seed(seed+1)
y = rnorm(n = n,
mean = .2 * x)  # coefficient is population ds
d = data.frame(x, y)
##### Compare True to Converted d #####
res = data.frame( q = seq(0.01, 0.99, 0.05))
res = res %>% rowwise() %>%
mutate( get_SMDs(q) )
min(res$dConv)
max(res$dConv)
ggplot( data = res,
aes(x = q,
y = dConv) ) +
# true d doesn't depend on cutoff, so there's only 1 unique value
geom_hline( yintercept = unique(res$dTrue),
lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / unique(res$dTrue),
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
theme_classic()
#set.seed(seed)
x = rbinom(n = n,
size = 1,
prob = 0.5)
#set.seed(seed+1)
y = rnorm(n = n,
mean = 1 * x)  # coefficient is population ds
d = data.frame(x, y)
##### Compare True to Converted d #####
res = data.frame( q = seq(0.01, 0.99, 0.05))
res = res %>% rowwise() %>%
mutate( get_SMDs(q) )
min(res$dConv)
max(res$dConv)
ggplot( data = res,
aes(x = q,
y = dConv) ) +
# true d doesn't depend on cutoff, so there's only 1 unique value
geom_hline( yintercept = unique(res$dTrue),
lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / unique(res$dTrue),
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
theme_classic()
# true d doesn't depend on cutoff, so there's only 1 unique value
.dTrue = unique(res$dTrue)
ggplot( data = res,
aes(x = q,
y = dConv) ) +
geom_hline( yintercept = .dTrue,
lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / .dTrue,
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
ggtitle( paste( "True sample d = ", round(.dTrue, 2) ) ) +
theme_classic()
#set.seed(seed)
x = rbinom(n = n,
size = 1,
prob = 0.5)
#set.seed(seed+1)
y = rnorm(n = n,
mean = .1 * x)  # coefficient is population ds
d = data.frame(x, y)
##### Compare True to Converted d #####
res = data.frame( q = seq(0.01, 0.99, 0.05))
res = res %>% rowwise() %>%
mutate( get_SMDs(q) )
min(res$dConv)
max(res$dConv)
# true d doesn't depend on cutoff, so there's only 1 unique value
.dTrue = unique(res$dTrue)
ggplot( data = res,
aes(x = q,
y = dConv) ) +
geom_hline( yintercept = .dTrue,
lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / .dTrue,
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
ggtitle( paste( "True sample d = ", round(.dTrue, 2) ) ) +
theme_classic()
#set.seed(seed)
x = rbinom(n = n,
size = 1,
prob = 0.5)
#set.seed(seed+1)
y = rnorm(n = n,
mean = .5 * x)  # coefficient is population ds
d = data.frame(x, y)
##### Compare True to Converted d #####
res = data.frame( q = seq(0.01, 0.99, 0.05))
res = res %>% rowwise() %>%
mutate( get_SMDs(q) )
min(res$dConv)
max(res$dConv)
# true d doesn't depend on cutoff, so there's only 1 unique value
.dTrue = unique(res$dTrue)
ggplot( data = res,
aes(x = q,
y = dConv) ) +
geom_hline( yintercept = .dTrue,
lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / .dTrue,
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
ggtitle( paste( "True sample d = ", round(.dTrue, 2) ) ) +
theme_classic()
#set.seed(seed)
x = rbinom(n = n,
size = 1,
prob = 0.5)
#set.seed(seed+1)
y = rnorm(n = n,
mean = 2 * x)  # coefficient is population ds
d = data.frame(x, y)
##### Compare True to Converted d #####
res = data.frame( q = seq(0.01, 0.99, 0.05))
res = res %>% rowwise() %>%
mutate( get_SMDs(q) )
min(res$dConv)
max(res$dConv)
# true d doesn't depend on cutoff, so there's only 1 unique value
.dTrue = unique(res$dTrue)
ggplot( data = res,
aes(x = q,
y = dConv) ) +
geom_hline( yintercept = .dTrue,
lty = 2,
color = "red") +
geom_line() +
scale_y_continuous( name = "Converted d (red line = true d)",
#limits = c(0, .4),
#breaks = seq(0, .4, .05),
sec.axis = sec_axis(trans = ~ . / .dTrue,
name = "Converted d / True sample d" ) ) +
scale_x_continuous( name = "Quantile of Y dichotomization",
limits = c(0, 1),
breaks = seq(0, 1, .1)) +
ggtitle( paste( "True sample d = ", round(.dTrue, 2) ) ) +
theme_classic()
rm(list=ls())
library(readxl)
library(dplyr)
library(ggplot2)
library(MetaUtility)
library(robumeta)
library(testthat)
root.dir = "~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology"
raw.data.dir = paste(root.dir, "Raw data", sep="/")
prepped.data.dir = paste(root.dir, "Prepped data", sep="/")
code.dir = paste(root.dir, "Code (git)", sep="/")
results.dir = paste(root.dir, "Results from R", sep="/")
setwd(code.dir)
source("helper.R")
setwd(prepped.data.dir)
d = read_xlsx("RP_CB Final Analysis .xlsx")
names(d)
dim(d)  # 258
table(d$`Replication attempted`)  # 233
table(d$`Experiment completed`) # 190
d %>% filter( `Experiment completed` == "Yes" ) %>%
summarise( length(unique(`Original study title`)),
mean(`Number of lab(s) contracted for the entire study`) )
data.frame( d %>% group_by(`Original study title`) %>%
summarise( n(),
comp = mean(`Experiment completed` == "Yes"),
expN0 = max(`Experiment #`, na.rm = TRUE),
max(`Study #`, na.rm = TRUE) ) )
####################################
# We will conduct the main analyses at two levels of granularity (outcome-level and experiment-level).
# distinctions in analysis:
#  - completed pairs (has realized replication outcome) vs. all pairs
#
# read back in
d2 = read_interm("intermediate_dataset_step2.csv")
##### Sanity checks on effect types #####
# bm
# @IMPORTANT: these are not necessarily Pearson's r!
#  some are Wilcoxon, so aren't comparable
# for the Pearson's r ones, find out if exposure was binary
#  or continuous
t = d2 %>% filter( !is.na(EStype) & EStype == "r" ) %>%
select(pID,
eID,
oID,
Statistical.test.applied.to.original.data,
What.statistical.test.was.reported.,
Original.test.statistic.type,
origES)
rm(list=ls())
library(readxl)
library(dplyr)
library(ggplot2)
library(MetaUtility)
library(robumeta)
library(testthat)
library(data.table)
library(tableone)
library(qdapTools)
root.dir = "~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology"
raw.data.dir = paste(root.dir, "Raw data", sep="/")
prepped.data.dir = paste(root.dir, "Prepped data", sep="/")
code.dir = paste(root.dir, "Code (git)", sep="/")
setwd(code.dir)
source("helper.R")
# should View2() open tabs?
useView = FALSE
# read in paper-, experiment-, and outcome-level data
setwd(raw.data.dir)
# we won't actually be using the first of these
dp = read_xlsx("2020_10_5_raw_data.xlsx", sheet = "Paper level data"); nrow(dp)
de = read_xlsx("2020_10_5_raw_data.xlsx", sheet = "Experiment level data"); nrow(de)
do = read_xlsx("2020_10_5_raw_data.xlsx", sheet = "Outcome level data"); nrow(do)
##### Sanity Checks on Hierarchical Data Structure #####
# nesting levels: paper > experiment > outcome
names(de)
# exp-level data have 196 unique paper-exp combos:
uni( paste(de$`Paper #`, de$`Experiment #` ) )
# and 53 papers
uni(de$`Paper #`)
# outcome-level data have only 50 unique paper-exp combos:
uni( paste(do$`Paper #`, do$`Experiment #` ) )
# and 23 papers
uni(do$`Paper #`)
# outcome-level only contains ones with quantitative effect sizes:
table( is.na(do$`Original effect size`))
# confirm that outcome-level data have all papers from exp-level data for
#  which the replication was completed
expect_equal( uni(de$`Paper #`[de$`Replication experiment completed` == "Yes"]),
uni(do$`Paper #`) )
##### Look at What Info Is in Each Dataset #####
# variables that only appear in one or the other dataset
names(do)[ !names(do) %in% names(de) ]
names(de)[ !names(de) %in% names(do) ]  # moderators
# anything non-overlapping in paper-level data?
names(dp)[ !names(dp) %in% c(names(de), names(do)) ]
# variables in both datasets
names(do)[ names(do) %in% names(de) ]
names(dp)[ names(dp) %in% names(de) ]
##### Merge Datasets #####
d = merge( do, de, by = c("Paper #", "Experiment #"), all=TRUE )
nrow(d)
# because de has a superset of do's papers and experiments:
expect_equal( uni(d$`Paper #`), uni(de$`Paper #`) )
expect_equal( uni(d$`Experiment #`), uni(de$`Experiment #`) )
# this time don't keep papers that don't even give experiment-level data
# i.e., left-join
d = merge( d, dp, by = "Paper #", all.x = TRUE)
nrow(d)
setwd(code.dir)
source("helper.R")
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
setwd(code.dir)
source("helper.R")
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
# read back in
d2 = read_interm("intermediate_dataset_step2.csv")
##### Sanity checks on effect types #####
# bm
# @IMPORTANT: these are not necessarily Pearson's r!
#  some are Wilcoxon, so aren't comparable
# for the Pearson's r ones, find out if exposure was binary
#  or continuous
t = d2 %>% filter( !is.na(EStype) & EStype == "r" ) %>%
select(pID,
eID,
oID,
Statistical.test.applied.to.original.data,
What.statistical.test.was.reported.,
Original.test.statistic.type,
origES)
View2(t)
useView = TRUE
# read back in
d2 = read_interm("intermediate_dataset_step2.csv")
##### Sanity checks on effect types #####
# bm
# @IMPORTANT: these are not necessarily Pearson's r!
#  some are Wilcoxon, so aren't comparable
# for the Pearson's r ones, find out if exposure was binary
#  or continuous
t = d2 %>% filter( !is.na(EStype) & EStype == "r" ) %>%
select(pID,
eID,
oID,
Statistical.test.applied.to.original.data,
What.statistical.test.was.reported.,
Original.test.statistic.type,
origES)
View2(t)
#  or continuous
t = d2 %>% filter( !is.na(EStype) & EStype == "r" ) %>%
select(pID,
eID,
oID,
Statistical.test.applied.to.original.data,
Original.test.statistic.value,
What.statistical.test.was.reported.,
Original.test.statistic.type,
origES)
View2(t)
# original s
unique(d$`Statistical test applied to original data`)
# these make sense
SMDtypes = c("Cliff's delta", "Cohen's d", "Cohen's dz", "Glass' delta")
t = d2 %>% filter( !is.na(EStype) & EStype %in% SMDtypes ) %>%
select(EStype,
pID,
eID,
oID,
Statistical.test.applied.to.original.data,
What.statistical.test.was.reported.,
Original.test.statistic.type,
origES)
View2(t)
# original statistical test (note: @a lot of NAs here)
t %>% group_by(Statistical.test.applied.to.original.data) %>%
summarise(n())
# HRs
t = d2 %>% filter( !is.na(EStype) & EStype %in% "Hazard ratio" ) %>%
select(pID,
eID,
oID,
Statistical.test.applied.to.original.data,
What.statistical.test.was.reported.,
Original.test.statistic.type,
origES)
t
uni(d$`Statistical test applied to original data`)
unique(d$`Statistical test applied to original data`)
table(d2$EStype)
t = d2 %>% group_by(EStype, Statistical.test.applied.to.original.data) %>%
summarise(n())
t
temp = c("between-subjects ANOVA", "Kruskal-Wallis rank sum test", "Kruskal-Wallis rank sum test", "Kruskal-Wallis rank sum test")
d2$peoID[ d2$EStype %ni% c("Cliff's delta", "Cohen's w" | d2$Statistical.test.applied.to.original.data %in% temp ]
# @for Tim: ones for which we want means and SDs
temp = c("between-subjects ANOVA", "Kruskal-Wallis rank sum test", "Kruskal-Wallis rank sum test", "Kruskal-Wallis rank sum test")
d2$peoID[ d2$EStype %ni% c("Cliff's delta", "Cohen's w" ) | d2$Statistical.test.applied.to.original.data %in% temp ]
# @for Tim: ones for which we want means and SDs
temp = c("between-subjects ANOVA", "Kruskal-Wallis rank sum test", "Kruskal-Wallis rank sum test", "Kruskal-Wallis rank sum test")
d2$peoID[ d2$EStype %in% c("Cliff's delta", "Cohen's w" ) | d2$Statistical.test.applied.to.original.data %in% temp ]
