# d = read_xlsx("RP_CB Final Analysis .xlsx")
#
# names(d)
#
#
# dim(d)  # 258
#
# table(d$`Replication attempted`)  # 233
# table(d$`Experiment completed`) # 190
#
# d %>% filter( `Experiment completed` == "Yes" ) %>%
#   summarise( length(unique(`Original study title`)),
#              mean(`Number of lab(s) contracted for the entire study`) )
#
# data.frame( d %>% group_by(`Original study title`) %>%
#               summarise( n(),
#                          comp = mean(`Experiment completed` == "Yes"),
#                          expN0 = max(`Experiment #`, na.rm = TRUE),
#                          max(`Study #`, na.rm = TRUE) ) )
####################################
# We will conduct the main analyses at two levels of granularity (outcome-level and experiment-level).
# distinctions in analysis:
#  - completed pairs (has realized replication outcome) vs. all pairs
#
# with eye toward functionizing everything later (so we can do for outcome- and exp-level):
dat = d
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                     METRICS FOR ALL PAIRS (INCL NON-COMPLETED)                                #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Percent sign agreement: The percentage of replications whose estimates agree in direction with the original study. This could be heuristically compared to the 50% that would be expected by chance if the null holds exactly in every replication (i.e., no effect heterogeneity) and conditional on all originals’ being positive in sign.
table(dat$origDirection, dat$repDirection, useNA = "ifany")
mean( dat$repDirection == "Positive" )
sum( dat$repDirection == "Positive" )
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#              MAIN PAIRWISE METRICS (COMPLETED QUANT PAIRS)                        #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
################################ CALCULATE PAIRWISE METRICS ################################
# Primary: Prediction interval and whether replication falls inside it (assuming t2=0)
# Make forest plot of these, including Porig on the side
# Primary: Porig
# Primary: Ratio of original to replication study estimates
# Secondary: P(Replication p < .05) with 2 expectation benchmarks
#  - from JRSSA paper
#  - the true effect size in each original is equal to the effect size for which it would
#   have had 80% power.
# Porig with assumed zero heterogeneity
# Fixed-effects pooled estimate: A meta-analytic pooled estimate of the original and replication estimates from each pair.
# As sensitivity analysis:
# Porig and pred interval with imputed heterogeneity: If there is moderate or high within-pair effect heterogeneity, this could make the original studies appear less consistent with the replications than they truly are. As a sensitivity analysis, we will impute the average heterogeneity estimate from Olsson-Collentine, et al. (in press), which was tau=0.13 on the SMD scale, and use this to re-calculate Porig for each pair. These values of Porig will likely be large (i.e., indicating better consistency) than those from main analyses.
# dataset has already been aggregated to either the outcome- or the experiment-level
dat = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
fake=deltamethod( ~ x1/x2,
mean = c( origES2, repES2 ), cov = diag( c(origVar2, repVar2) ) )
fake
origES2/ repES2
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                              PRELIMINARIES                                #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
rm(list=ls())
library(readxl)
library(dplyr)
library(ggplot2)
library(MetaUtility)
library(robumeta)
library(testthat)
library(Replicate)
root.dir = "~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology"
raw.data.dir = paste(root.dir, "Raw data", sep="/")
prepped.data.dir = paste(root.dir, "Prepped data", sep="/")
code.dir = paste(root.dir, "Code (git)", sep="/")
results.dir = paste(root.dir, "Results from R", sep="/")
options(scipen=999)
setwd(code.dir)
source("helper.R")
setwd(prepped.data.dir)
d = fread("prepped_outcome_level_data.csv")
# read in codebook for easy searching
setwd(raw.data.dir)
cd = fread("codebook_merged.csv")
# d = read_xlsx("RP_CB Final Analysis .xlsx")
#
# names(d)
#
#
# dim(d)  # 258
#
# table(d$`Replication attempted`)  # 233
# table(d$`Experiment completed`) # 190
#
# d %>% filter( `Experiment completed` == "Yes" ) %>%
#   summarise( length(unique(`Original study title`)),
#              mean(`Number of lab(s) contracted for the entire study`) )
#
# data.frame( d %>% group_by(`Original study title`) %>%
#               summarise( n(),
#                          comp = mean(`Experiment completed` == "Yes"),
#                          expN0 = max(`Experiment #`, na.rm = TRUE),
#                          max(`Study #`, na.rm = TRUE) ) )
####################################
# We will conduct the main analyses at two levels of granularity (outcome-level and experiment-level).
# distinctions in analysis:
#  - completed pairs (has realized replication outcome) vs. all pairs
#
# with eye toward functionizing everything later (so we can do for outcome- and exp-level):
dat = d
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                     METRICS FOR ALL PAIRS (INCL NON-COMPLETED)                                #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Percent sign agreement: The percentage of replications whose estimates agree in direction with the original study. This could be heuristically compared to the 50% that would be expected by chance if the null holds exactly in every replication (i.e., no effect heterogeneity) and conditional on all originals’ being positive in sign.
table(dat$origDirection, dat$repDirection, useNA = "ifany")
mean( dat$repDirection == "Positive" )
sum( dat$repDirection == "Positive" )
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#              MAIN PAIRWISE METRICS (COMPLETED QUANT PAIRS)                        #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
################################ CALCULATE PAIRWISE METRICS ################################
# Primary: Prediction interval and whether replication falls inside it (assuming t2=0)
# Make forest plot of these, including Porig on the side
# Primary: Porig
# Primary: Ratio of original to replication study estimates
# Secondary: P(Replication p < .05) with 2 expectation benchmarks
#  - from JRSSA paper
#  - the true effect size in each original is equal to the effect size for which it would
#   have had 80% power.
# Porig with assumed zero heterogeneity
# Fixed-effects pooled estimate: A meta-analytic pooled estimate of the original and replication estimates from each pair.
# As sensitivity analysis:
# Porig and pred interval with imputed heterogeneity: If there is moderate or high within-pair effect heterogeneity, this could make the original studies appear less consistent with the replications than they truly are. As a sensitivity analysis, we will impute the average heterogeneity estimate from Olsson-Collentine, et al. (in press), which was tau=0.13 on the SMD scale, and use this to re-calculate Porig for each pair. These values of Porig will likely be large (i.e., indicating better consistency) than those from main analyses.
# dataset has already been aggregated to either the outcome- or the experiment-level
dat = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
# quick look at results
# stringsWith( pattern = "pw", x = names(dat) )
#
takeMean = c("pw.PIRepInside",
"pw.PIRepInside.sens",
"pw.Porig",
"pw.PorigSens",
"pw.ratio",
"pw.PsigAgree1",
"pw.FEest")
# this is broken:
# res = dat %>% select(takeMean) %>%
#   mutate( across( .cols = everything(),
#                   .fns = mean) )
colMeans( dat %>% select(takeMean), na.rm = TRUE )
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                              PRELIMINARIES                                #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
rm(list=ls())
library(readxl)
library(dplyr)
library(ggplot2)
library(MetaUtility)
library(robumeta)
library(testthat)
library(Replicate)
root.dir = "~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology"
raw.data.dir = paste(root.dir, "Raw data", sep="/")
prepped.data.dir = paste(root.dir, "Prepped data", sep="/")
code.dir = paste(root.dir, "Code (git)", sep="/")
results.dir = paste(root.dir, "Results from R", sep="/")
options(scipen=999)
setwd(code.dir)
source("helper.R")
setwd(prepped.data.dir)
d = fread("prepped_outcome_level_data.csv")
# read in codebook for easy searching
setwd(raw.data.dir)
cd = fread("codebook_merged.csv")
# d = read_xlsx("RP_CB Final Analysis .xlsx")
#
# names(d)
#
#
# dim(d)  # 258
#
# table(d$`Replication attempted`)  # 233
# table(d$`Experiment completed`) # 190
#
# d %>% filter( `Experiment completed` == "Yes" ) %>%
#   summarise( length(unique(`Original study title`)),
#              mean(`Number of lab(s) contracted for the entire study`) )
#
# data.frame( d %>% group_by(`Original study title`) %>%
#               summarise( n(),
#                          comp = mean(`Experiment completed` == "Yes"),
#                          expN0 = max(`Experiment #`, na.rm = TRUE),
#                          max(`Study #`, na.rm = TRUE) ) )
####################################
# We will conduct the main analyses at two levels of granularity (outcome-level and experiment-level).
# distinctions in analysis:
#  - completed pairs (has realized replication outcome) vs. all pairs
#
# with eye toward functionizing everything later (so we can do for outcome- and exp-level):
dat = d
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                     METRICS FOR ALL PAIRS (INCL NON-COMPLETED)                                #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Percent sign agreement: The percentage of replications whose estimates agree in direction with the original study. This could be heuristically compared to the 50% that would be expected by chance if the null holds exactly in every replication (i.e., no effect heterogeneity) and conditional on all originals’ being positive in sign.
table(dat$origDirection, dat$repDirection, useNA = "ifany")
mean( dat$repDirection == "Positive" )
sum( dat$repDirection == "Positive" )
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#              MAIN PAIRWISE METRICS (COMPLETED QUANT PAIRS)                        #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
################################ CALCULATE PAIRWISE METRICS ################################
# Primary: Prediction interval and whether replication falls inside it (assuming t2=0)
# Make forest plot of these, including Porig on the side
# Primary: Porig
# Primary: Ratio of original to replication study estimates
# Secondary: P(Replication p < .05) with 2 expectation benchmarks
#  - from JRSSA paper
#  - the true effect size in each original is equal to the effect size for which it would
#   have had 80% power.
# Porig with assumed zero heterogeneity
# Fixed-effects pooled estimate: A meta-analytic pooled estimate of the original and replication estimates from each pair.
# As sensitivity analysis:
# Porig and pred interval with imputed heterogeneity: If there is moderate or high within-pair effect heterogeneity, this could make the original studies appear less consistent with the replications than they truly are. As a sensitivity analysis, we will impute the average heterogeneity estimate from Olsson-Collentine, et al. (in press), which was tau=0.13 on the SMD scale, and use this to re-calculate Porig for each pair. These values of Porig will likely be large (i.e., indicating better consistency) than those from main analyses.
# dataset has already been aggregated to either the outcome- or the experiment-level
dat = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
# quick look at results
# stringsWith( pattern = "pw", x = names(dat) )
#
takeMean = c("pw.PIRepInside",
"pw.PIRepInside.sens",
"pw.Porig",
"pw.PorigSens",
"pw.ratio",
"pw.PsigAgree1",
"pw.FEest")
# this is broken:
# res = dat %>% select(takeMean) %>%
#   mutate( across( .cols = everything(),
#                   .fns = mean) )
colMeans( dat %>% select(takeMean), na.rm = TRUE )
dat %>% select(takeMean)
dat = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
rlang::last_error()
analyze_one_row( dat$origES2[139],
dat$origVar2[139],
dat$repES2[139],
dat$repVar2[139],
dat$ES2type[139])
# dataset has already been aggregated to either the outcome- or the experiment-level
dat = dat[1:10,] %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                              PRELIMINARIES                                #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
rm(list=ls())
library(readxl)
library(dplyr)
library(ggplot2)
library(MetaUtility)
library(robumeta)
library(testthat)
library(Replicate)
root.dir = "~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology"
raw.data.dir = paste(root.dir, "Raw data", sep="/")
prepped.data.dir = paste(root.dir, "Prepped data", sep="/")
code.dir = paste(root.dir, "Code (git)", sep="/")
results.dir = paste(root.dir, "Results from R", sep="/")
options(scipen=999)
setwd(code.dir)
source("helper.R")
setwd(prepped.data.dir)
d = fread("prepped_outcome_level_data.csv")
# read in codebook for easy searching
setwd(raw.data.dir)
cd = fread("codebook_merged.csv")
# d = read_xlsx("RP_CB Final Analysis .xlsx")
#
# names(d)
#
#
# dim(d)  # 258
#
# table(d$`Replication attempted`)  # 233
# table(d$`Experiment completed`) # 190
#
# d %>% filter( `Experiment completed` == "Yes" ) %>%
#   summarise( length(unique(`Original study title`)),
#              mean(`Number of lab(s) contracted for the entire study`) )
#
# data.frame( d %>% group_by(`Original study title`) %>%
#               summarise( n(),
#                          comp = mean(`Experiment completed` == "Yes"),
#                          expN0 = max(`Experiment #`, na.rm = TRUE),
#                          max(`Study #`, na.rm = TRUE) ) )
####################################
# We will conduct the main analyses at two levels of granularity (outcome-level and experiment-level).
# distinctions in analysis:
#  - completed pairs (has realized replication outcome) vs. all pairs
#
# with eye toward functionizing everything later (so we can do for outcome- and exp-level):
dat = d
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                     METRICS FOR ALL PAIRS (INCL NON-COMPLETED)                                #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Percent sign agreement: The percentage of replications whose estimates agree in direction with the original study. This could be heuristically compared to the 50% that would be expected by chance if the null holds exactly in every replication (i.e., no effect heterogeneity) and conditional on all originals’ being positive in sign.
table(dat$origDirection, dat$repDirection, useNA = "ifany")
mean( dat$repDirection == "Positive" )
sum( dat$repDirection == "Positive" )
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#              MAIN PAIRWISE METRICS (COMPLETED QUANT PAIRS)                        #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
################################ CALCULATE PAIRWISE METRICS ################################
# Primary: Prediction interval and whether replication falls inside it (assuming t2=0)
# Make forest plot of these, including Porig on the side
# Primary: Porig
# Primary: Ratio of original to replication study estimates
# Secondary: P(Replication p < .05) with 2 expectation benchmarks
#  - from JRSSA paper
#  - the true effect size in each original is equal to the effect size for which it would
#   have had 80% power.
# Porig with assumed zero heterogeneity
# Fixed-effects pooled estimate: A meta-analytic pooled estimate of the original and replication estimates from each pair.
# As sensitivity analysis:
# Porig and pred interval with imputed heterogeneity: If there is moderate or high within-pair effect heterogeneity, this could make the original studies appear less consistent with the replications than they truly are. As a sensitivity analysis, we will impute the average heterogeneity estimate from Olsson-Collentine, et al. (in press), which was tau=0.13 on the SMD scale, and use this to re-calculate Porig for each pair. These values of Porig will likely be large (i.e., indicating better consistency) than those from main analyses.
fake = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
analyze_one_row( dat$origES2[139],
dat$origVar2[139],
dat$repES2[139],
dat$repVar2[139],
dat$ES2type[139])
fake = dat[139,] %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
fake = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
# "pw" prefix for "pairwise" metrics
return( data.frame( pw.PILo = predInt$int.lo,
pw.PIHi = predInt$int.hi,
pw.PIRepInside = predInt$rep.inside,
pw.PILo.sens = PILo.sens,
pw.PIHi.sens = PIHi.sens,
pw.PIRepInside.sens = PIinside.sens,
pw.Porig = Porig,
pw.PorigSens = Porig.sens,
pw.ratio = origES2 / repES2,
pw.ratioVar = pw.ratioVar,
pw.PsigAgree1 = PsigAgree1,
pw.FEest = as.numeric( FEmod$b ),
pw.FEvar = as.numeric( FEmod$se^2 ),
pw.FElo = as.numeric( FEmod$ci.lb ),
pw.FEhi = as.numeric( FEmod$ci.ub )
) )
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
debug any rows that are brats
analyze_one_row( dat$origES2[139],
dat$origVar2[139],
dat$repES2[139],
dat$repVar2[139],
dat$ES2type[139])
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
fake = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
fake = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
fake = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
fake = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
# debug any rows that are brats
analyze_one_row( dat$origES2[139],
dat$origVar2[139],
dat$repES2[139],
dat$repVar2[139],
dat$ES2type[139])
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
# @@assign back to dat when un-broken
fake = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
# @@assign back to dat when un-broken
fake = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
# @@assign back to dat when un-broken
fake = dat %>%
rowwise() %>%
mutate( analyze_one_row(origES2,
origVar2,
repES2,
repVar2,
ES2type) )
for ( i in 1:nrow(dat) ) {
# debug any rows that are brats
analyze_one_row( dat$origES2[i],
dat$origVar2[i],
dat$repES2[i],
dat$repVar2[i],
dat$ES2type[i])
}
for ( i in 1:nrow(dat) ) {
# debug any rows that are brats
chunk = analyze_one_row( dat$origES2[i],
dat$origVar2[i],
dat$repES2[i],
dat$repVar2[i],
dat$ES2type[i])
if ( i == 1 ) res = chunk
if ( i > 1) res = rbind(res, chunk)
}
i
chunk
res
dim(res)
dim(chunj)
dim(chunk)
names(res)[ !names(res) %in% names(chunk)]
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
i
chunk = analyze_one_row( dat$origES2[i],
dat$origVar2[i],
dat$repES2[i],
dat$repVar2[i],
dat$ES2type[i])
if ( i == 1 ) res = chunk
chunk
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
chunk = analyze_one_row( dat$origES2[i],
dat$origVar2[i],
dat$repES2[i],
dat$repVar2[i],
dat$ES2type[i])
if ( i == 1 ) res = chunk
source('~/Dropbox/Personal computer/Independent studies/2020/RPCB reproducibility cancer biology/Code (git)/helper.R')
chunk = analyze_one_row( dat$origES2[i],
dat$origVar2[i],
dat$repES2[i],
dat$repVar2[i],
dat$ES2type[i])
